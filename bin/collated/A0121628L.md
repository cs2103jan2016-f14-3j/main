# A0121628L
###### storage\Storage.java
``` java
 *
 */
public class Storage {
	private final String DEFAULT_FILE_DIRECTORY = "PomPom Storage & Settings";
	private final String DEFAULT_FILE_NAME = "Storage.txt";
	private final String DEFAULT_STORAGE_FILE_PATH = DEFAULT_FILE_DIRECTORY
			+ "/" + DEFAULT_FILE_NAME;

	// storageFile is not final as user can reset storage file path
	private final File DEFAULT_DIRECTORY_FILE = new File(DEFAULT_FILE_DIRECTORY);
	private File storageFile = new File(DEFAULT_STORAGE_FILE_PATH);
	private String storageFilePath = DEFAULT_STORAGE_FILE_PATH;

	private final String SETTINGS_FILE_NAME = "settings.txt";
	private final String SETTINGS_FILE_PATH = DEFAULT_FILE_DIRECTORY + "/"
			+ SETTINGS_FILE_NAME;

	private final File settingsFile = new File(SETTINGS_FILE_PATH);
	private Settings settings;

	// The main data that is being extracted to this objects
	private UserItemList userTaskList;
	private ArrayList<Item> taskList;
	


	private long idCounter;
	public PrettyTimeParser timeParser;

	// Gson Library objects to read settings and storage file in json format
	final GsonBuilder GSON_ITEM_BUILDER = new GsonBuilder();
	final GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
	private Gson gsonItem;
	private Gson gsonSettings;

	private Logger logger = Logger.getLogger("Storage");

	public Storage() throws IOException {
		
	}
	
	public void init() throws IOException {
		initializeGsonObjects();
		initializeSettings();
		initializeStorage();
		logger.log(Level.INFO, "Initialized Storage");
		// Loading NLP library for parser for quick access
		
	}

	// Getters and Setters
	public UserItemList getUserTaskList() {
		return userTaskList;
	}

	public void setUserTaskList(UserItemList userTaskList) {
		this.userTaskList = userTaskList;
	}

	public ArrayList<Item> getTaskList() {
		return taskList;
	}

	public void setTaskList(ArrayList<Item> taskList) {
		this.taskList = taskList;
	}

	public long getIdCounter() {
		idCounter = idCounter + 1;
		return idCounter;
	}

	public void setIdCounter(long idCounter) {
		this.idCounter = idCounter;
	}

	public void setStorageFile(File storageFile) {
		this.storageFile = storageFile;
	}

	public void setStorageFilePath(String storageFilePath) {
		this.storageFilePath = storageFilePath;
	}
	public String getStorageFilePath() {
		return storageFilePath;
	}

	// Initializing the GSON objects to read the storage text data file in JSON
	private void initializeGsonObjects() {
		GSON_ITEM_BUILDER.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		GSON_ITEM_BUILDER.setPrettyPrinting();
		gsonItem = GSON_ITEM_BUILDER.create();

		GSON_SETTINGS_BUILDER.registerTypeAdapter(Settings.class,
				new SettingsAdapter());
		GSON_SETTINGS_BUILDER.setPrettyPrinting();
		gsonSettings = GSON_SETTINGS_BUILDER.create();
	}

	private void initializeSettings() {
		// Check set directory folder exisit a not if not create folder
		checkDirectoryFolder();
		try {
			// Check Settings file exist a not if not create file
			checkSettingsFile();
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Failure Settings Path: "
					+ SETTINGS_FILE_PATH);
			e.printStackTrace();
		}
		String settingsString = null;
		try {

			settingsString = FileHandler.getStringFromFile(SETTINGS_FILE_PATH,
					StandardCharsets.UTF_8);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Failure Reading Settings ");
			e.printStackTrace();
		}
		//
		settings = deserializeSettingsString(settingsString);
	}

	private void initializeStorage() throws IOException {
		// Check for user set directory. If exist use directory
		if (hasStoragePath()) {
			setStorageFile(new File(settings.getStoragePath()));
			setStorageFilePath(settings.getStoragePath());
		}
		// Check for storage file if do not exist create file
		
		checkStorageFile();
		String storageString = FileHandler.getStringFromFile(storageFilePath,
				StandardCharsets.UTF_8);
		userTaskList = deserializeStorageString(storageString);
		taskList = userTaskList.getTaskArray();
		idCounter = userTaskList.getIdCounter();
	}

	private boolean hasStoragePath() {
		return settings.getStoragePath() != null;
	}

	// If do not exist make directory
	private boolean checkDirectoryFolder() {
		if (!DEFAULT_DIRECTORY_FILE.exists()) {
			DEFAULT_DIRECTORY_FILE.mkdir();
			return false;
		}
		return true;
	}

	// If Storage file do not exist make file
	private boolean checkStorageFile() throws IOException {
		if (!storageFile.exists()) {
			storageFile.getParentFile().mkdirs();
			storageFile.createNewFile();
			return false;
		}
		return true;
	}

	// If settings file do not exist make file
	private boolean checkSettingsFile() throws IOException {
		if (!settingsFile.exists()) {
			settingsFile.createNewFile();
			Settings defaultSettings = new Settings();
			defaultSettings.setStoragePath(DEFAULT_STORAGE_FILE_PATH);
			final String json = gsonSettings.toJson(defaultSettings);
			FileHandler.writeStringToFile(settingsFile, json);
		}
		return true;
	}

	private boolean checkEmptyString(String string) {
		if (string.equals("") || string.equals(null)) {
			return true;
		} else {
			return false;
		}

	}
	// Use the Gson library to get a Storage object from String
	private UserItemList deserializeStorageString(String jsonString) {
		if (checkEmptyString(jsonString)) {
			UserItemList utl = new UserItemList("Not Set",
					new ArrayList<Item>());
			utl.setIdCounter(0);
			taskList = new ArrayList<Item>();
			return utl;
		}
		UserItemList userTaskList = gsonItem.fromJson(jsonString,
				UserItemList.class);

		return userTaskList;
	}

	// Use the Gson library to get a Settings object from String
	private Settings deserializeSettingsString(String jsonString) {
		if (jsonString.equals("")) {
			Settings newSettings = new Settings();
			return newSettings;
		}
		return gsonSettings.fromJson(jsonString, Settings.class);
	}

	// Obsolete method for now
	public void store(UserItemList lst) throws IOException {
		final String json = gsonItem.toJson(lst);
		FileHandler.writeStringToFile(storageFile, json);

	}

	public void saveStorage() throws IOException {
		userTaskList.setTaskArray(taskList);
		userTaskList.setIdCounter(idCounter);
		final String json = gsonItem.toJson(userTaskList);
		FileHandler.writeStringToFile(storageFile, json);
	}



	public void saveSettings() throws IOException {
		assert settings != null : "Settings not set";
		settings.setStoragePath(storageFilePath);
		final String json = gsonSettings.toJson(settings);
		FileHandler.writeStringToFile(settingsFile, json);
	}
}
```
###### Test\GsonTest.java
``` java
 *
 */

public class GsonTest {
	// Basic example to show my teammates how the gson library works.
	// UserItemList objects for test
	GsonBuilder GSON_ITEM_BUILDER;
	Gson gsonItem;

	UserItemList taskListInput;
	Item item1;
	Item item2;
	long initialCounter;

	// Settings Objects for test
	GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
	Gson gsonSettings;
	Settings settings;
	private final String TEST_STORAGE_STRING = "TEST";

	// Create a gson String builder to create a text . we register
	// UserItemList to write this
	// Object into a string. So a Gsonbuilder will create a instance of gson
	// to do this.
	@Before
	public void initObjects() {
		// Gson objects for UserItemList
		GSON_ITEM_BUILDER = new GsonBuilder();
		GSON_ITEM_BUILDER.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		GSON_ITEM_BUILDER.setPrettyPrinting();
		gsonItem = GSON_ITEM_BUILDER.create();
		// Gson Objects for settings
		final GsonBuilder GSON_SETTINGS_BUILDER = new GsonBuilder();
		GSON_SETTINGS_BUILDER.registerTypeAdapter(Settings.class,
				new SettingsAdapter());
		GSON_SETTINGS_BUILDER.setPrettyPrinting();
		gsonSettings = GSON_SETTINGS_BUILDER.create();

		// Add userItemList data
		taskListInput = new UserItemList();
		item1 = new Item(1L, "Event", "It is a sunny day", "High",
				"I want to swim", "Done", "red label", new Date(), new Date());

		item2 = new Item(2L, "Task", "It is a rainny day", "Medium",
				"I want to study", "Undone", "blue label", new Date(),
				new Date());
		initialCounter = 0L;
		taskListInput.setUserName("Wei Lip");
		taskListInput.setIdCounter(initialCounter);
		ArrayList<Item> tArray = new ArrayList<>();
		tArray.add(item1);
		tArray.add(item2);
		taskListInput.setTaskArray(tArray);

		// Add Settings data
		settings = new Settings();
		settings.setStoragePath(TEST_STORAGE_STRING);
	}

	/********************* Helper Methods **************************************/

	public boolean isSameItemList(ArrayList<Item> listA, ArrayList<Item> listB) {
		int lengthA = listA.size();
		int lengthB = listB.size();
		boolean sameList = true;
		if (lengthA != lengthB) {
			return false;
		} else {
			// Test every aspect of the item value are equals to each other
			for (int i = 0; i < lengthA; i++) {
				// If the previous item was not the same return false.
				if (!sameList) {
					return false;
				}
				Item currentItemA = listA.get(0);
				Item currentItemB = listB.get(0);

				sameList = currentItemA.getId().equals(currentItemB.getId());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getDescription().equals(
						currentItemB.getDescription());
				sameList = currentItemA.getLabel().equals(
						currentItemB.getLabel());
				sameList = currentItemA.getPriority().equals(
						currentItemB.getPriority());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
			}
			return sameList;
		}

	}

	/********************* Unit Tests **************************************/
	// Test the correct reading and writing of UserItemList object into the text
	// file
	@Test
	public void testGsonUserItemList() {
		final String itemJson = gsonItem.toJson(taskListInput);

		// get Object from above json string and test whether it writes to the
		// object with same values or not
		final UserItemList taskListOutput = gsonItem.fromJson(itemJson,
				UserItemList.class);

		assertEquals(taskListOutput.getUserName(), taskListInput.getUserName());
		assertEquals(taskListOutput.getIdCounter(),
				taskListInput.getIdCounter());
		ArrayList<Item> taskList1 = taskListOutput.getTaskArray();
		ArrayList<Item> taskList2 = taskListInput.getTaskArray();
		assertTrue(isSameItemList(taskList1, taskList2));

	}

	// Test the correct reading and writing of Settings object into the text
	// file
	@Test
	public void testGsonSettings() {
		final String settingsJson = gsonSettings.toJson(settings);

		final Settings settingsFromString = gsonSettings.fromJson(settingsJson,
				Settings.class);
		assertEquals(settingsFromString.getStoragePath(), TEST_STORAGE_STRING);

	}
}
```
###### Test\TestStorage.java
``` java
 *
 */
public class TestStorage {
	// Storage directory for testing
	private final String DEFAULT_FILE_DIRECTORY = "test";
	private final String DEFAULT_FILE_NAME = "Storage.txt";
	private final String DEFAULT_STORAGE_FILE_PATH_TESTING = DEFAULT_FILE_DIRECTORY
			+ "/" + DEFAULT_FILE_NAME;

	// Gson testing for reading and saving
	GsonBuilder gsonItemBuilder;
	Gson gsonItem;
	UserItemList taskListInput;

	Item item1;
	Item item2;
	Item item3 = new Item();
	Item item4 = new Item();
	Storage storageStub;
	String originalStorageFilePath;

	// Initialization of stub and item variables for adding later
	@Before
	public void initGson() {

		// Create a gson String builder to create a text . we register
		// UserItemList to write this
		// Object into a string. So a Gsonbuilder will create a instance of gson
		// to do this.
		gsonItemBuilder = new GsonBuilder();
		gsonItemBuilder.registerTypeAdapter(UserItemList.class,
				new ItemAdapter());
		gsonItemBuilder.setPrettyPrinting();
		gsonItem = gsonItemBuilder.create();
	}

	@Before
	public void initStorage() throws ParseException, IOException {
		// Change the storage file path for testing to another folder so that it
		// would
		// not affect the actual folder data
		storageStub = new Storage();
		storageStub.init();
		// Save the orignal file path and change back to it later
		originalStorageFilePath = storageStub.getStorageFilePath();
		// Create new storage for test
		File testFile = new File(DEFAULT_STORAGE_FILE_PATH_TESTING);
		testFile.delete();
		// Set to testing location and initialize storage
		storageStub.setStorageFilePath(DEFAULT_STORAGE_FILE_PATH_TESTING);
		storageStub.saveSettings();
		// Reinitialize storage with new storagefile
		storageStub.init();

		SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm");
		sdf.parse("Wed, 4 Jul 2016 12:08");

		item1 = new Item(1L, "Event", "Swim", "High", "Nice day", "Done",
				"red label", sdf.parse("Wed, 04 Jan 2016 12:08"),
				sdf.parse("Wed, 30 Jan 2016 12:08"));

		item2 = new Item(2L, "Task", "Sleep", "Medium", "yawn", "Undone",
				"blue label", sdf.parse("Wed, 04 Jul 2016 12:08"),
				sdf.parse("Wed, 11 Jul 2016 12:08"));

		item2 = new Item(3L, "Task", "Fight", "Medium", "Muay thai", "Undone",
				"blue label", sdf.parse("Wed, 01 Jul 2016 12:08"),
				sdf.parse("Wed, 10 Jul 2016 12:08"));

		item2 = new Item(4L, "Task", "Mug", "Medium", "I want to study",
				"Undone", "blue label", new Date(), new Date());
	}

	/********************* Helper Methods * @throws IOException **************************************/
	public boolean isSameItemList(ArrayList<Item> listA, ArrayList<Item> listB) {
		int lengthA = listA.size();
		int lengthB = listB.size();
		boolean sameList = true;
		if (lengthA != lengthB) {
			return false;
		} else {
			// Test every aspect of the item value are equals to each other
			for (int i = 0; i < lengthA; i++) {
				// If the previous item was not the same return false.
				if (!sameList) {
					return false;
				}
				Item currentItemA = listA.get(0);
				Item currentItemB = listB.get(0);

				sameList = currentItemA.getId().equals(currentItemB.getId());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getDescription().equals(
						currentItemB.getDescription());
				sameList = currentItemA.getLabel().equals(
						currentItemB.getLabel());
				sameList = currentItemA.getPriority().equals(
						currentItemB.getPriority());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
				sameList = currentItemA.getTitle().equals(
						currentItemB.getTitle());
			}
			return sameList;
		}

	}

	/********************* UNIT TEST CASES * @throws IOException **************************************/
	// tests whether the file specified will be created when the constructor is
	// called.

	@Test
	public void testInitialization() throws IOException {
		Storage testStorage = new Storage();
		testStorage.init();
		assertNotNull(testStorage.getIdCounter());
		assertNotNull(testStorage.getStorageFilePath());
		assertNotNull(testStorage.getTaskList());
		assertNotNull(testStorage.getUserTaskList());
	}

	// Test whether getIdCounter increments itself a not
	@Test
	public void correctIdRead() throws IOException {
		assertEquals(storageStub.getUserTaskList().getIdCounter() + 1,
				storageStub.getIdCounter());
	}

	// The code to initialize the storageFilePath is done in the method
	// initstorage
	// now we will just check whether the path is set correctly a not
	@Test
	public void testWriteToSettings() throws SecurityException, IOException {
		assertEquals(storageStub.getStorageFilePath(),
				DEFAULT_STORAGE_FILE_PATH_TESTING);
	}

	// We add the items to storage and save it. And test whether we can get back
	// the same items
	// using our gson file reader.
	@Test
	public void testAddAndSave() throws IOException {
		storageStub.getTaskList().add(item1);
		storageStub.getTaskList().add(item2);
		storageStub.getTaskList().add(item3);
		storageStub.getTaskList().add(item4);
		storageStub.saveStorage();
		// Read Storage file at location storageFilePath(Tested above) and
		// check for equivalence by reading storage file with Gson
		String jsonUserItemList = FileHandler.getStringFromFile(
				DEFAULT_STORAGE_FILE_PATH_TESTING, StandardCharsets.UTF_8);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	@Test
	public void testDeleteAndSave() throws IOException {
		storageStub.getTaskList().add(item1);
		storageStub.getTaskList().add(item2);
		storageStub.getTaskList().add(item3);
		storageStub.getTaskList().add(item4);
		storageStub.getTaskList().remove(2);
		storageStub.getTaskList().remove(1);
		storageStub.saveStorage();

		// Same code as above to check for equivalence
		String jsonUserItemList = FileHandler.getStringFromFile(
				DEFAULT_STORAGE_FILE_PATH_TESTING, StandardCharsets.UTF_8);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	@Test
	public void testEditAndSave() throws IOException {
		storageStub.getTaskList().add(item1);
		storageStub.getTaskList().add(item2);
		storageStub.getTaskList().add(item3);
		storageStub.getTaskList().add(item4);
		storageStub.getTaskList().get(0).setTitle("Testing title");
		storageStub.getTaskList().get(0).setTitle("Testing title 2");
		storageStub.saveStorage();

		// Same code as above to check for equivalence
		String jsonUserItemList = FileHandler.getStringFromFile(
				DEFAULT_STORAGE_FILE_PATH_TESTING, StandardCharsets.UTF_8);
		UserItemList taskListOutput = gsonItem.fromJson(jsonUserItemList,
				UserItemList.class);
		assertTrue(isSameItemList(storageStub.getTaskList(),
				taskListOutput.getTaskArray()));
	}

	// Change back the settings of the original User or tester
	@After
	public void returnToOriginalSettings() throws IOException {
		storageStub.setStorageFilePath(originalStorageFilePath);
		storageStub.saveSettings();
	}
}
```
###### utils\CheckBoxCellFactory.java
``` java
 *
 */
public class CheckBoxCellFactory implements Callback {
    @Override
    public TableCell call(Object param) {
        CheckBoxTableCell<Item,Boolean> checkBoxCell = new CheckBoxTableCell();
        
        return checkBoxCell;
    }
}
```
###### utils\FileHandler.java
``` java
 *
 */
public class FileHandler {
	public static void writeStringToFile(File file,String text) throws IOException{
		FileWriter out = new FileWriter(file);
		out.write(text);
		out.close();
	}
	
	public static String getStringFromFile(String path, Charset encoding) 
			  throws IOException {
	  byte[] encoded = Files.readAllBytes(Paths.get(path));
	  return new String(encoded, encoding);
	}
}
```
###### utils\Item.java
``` java
 *
 */
public class Item implements Comparator<Item> {
	private Long id;
	private String title;
	private String type;
	private String priority;
	private String description;
	private String status;
	private String label;
	private Date startDate;
	private Date endDate;
	private Boolean checkBox;

	// Check box code for testing for now
	private SimpleBooleanProperty checked = new SimpleBooleanProperty(false);

	public SimpleBooleanProperty checkedProperty() {
		return this.checked;
	}

	public Boolean getChecked() {
		return this.checkedProperty().get();
	}

	public void setChecked(final Boolean checked) {
		this.checkedProperty().set(checked);
	}

	public Item(Long id, String type, String title, String priority,
			String description, String status, String label, Date startDate,
			Date endDate) {
		super();
		this.id = id;
		this.type = type;
		this.title = title;
		this.priority = priority;
		this.description = description;
		this.status = status;
		this.label = label;
		this.startDate = startDate;
		this.endDate = endDate;
	}

	public Item() {

	}

	public Long getId() {
		return id;
	}

	public void setId(Long i) {
		this.id = i;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public String getPriority() {
		return priority;
	}

	public void setPriority(String priority) {
		this.priority = priority;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getLabel() {
		return label;
	}

	public void setLabel(String label) {
		this.label = label;
	}

	public Date getStartDate() {
		return startDate;
	}

	public void setStartDate(Date startDate) {
		this.startDate = startDate;
	}

	public Date getEndDate() {
		return endDate;
	}

	public void setEndDate(Date endDate) {
		this.endDate = endDate;
	}

	public Boolean getCheckBox() {
		return checkBox;
	}

	public void setCheckBox(Boolean checkBox) {
		this.checkBox = checkBox;
	}

	// Debugging Method
	public void printInfo() {
		System.out.println("");
		System.out.println("Task ID: " + getId());
		System.out.println("Type: " + getType());
		System.out.println("Title: " + getTitle());
		System.out.println("Priority: " + getPriority());
		System.out.println("Description: " + getDescription());
		System.out.println("Status: " + getStatus());
		System.out.println("Label: " + getLabel());
		System.out.println("StartDate: " + getStartDate());
		System.out.println("EndDate: " + getEndDate());
		System.out.println("");
	}



	@Override
	public int compare(Item item1, Item item2) {
		if (item2 == null) {
			return 1;
		}
		if (item1 == null) {
			return -1;
		}
		if (item1.getEndDate().compareTo(item2.getEndDate()) > 0) {
			return 1;
		}
		else if (item1.getEndDate().compareTo(item2.getEndDate()) < 0) {
			return -1;
		} 
		else if (item1.getEndDate().compareTo(item2.getEndDate()) == 0) {
			return 0;
		}
		return 0;
	}
}
```
###### utils\ItemAdapter.java
``` java
 *
 */

public class ItemAdapter extends TypeAdapter<UserItemList> {

	@Override
	public UserItemList read(JsonReader in) throws IOException {
		final UserItemList userTaskList = new UserItemList();
		SimpleDateFormat formatter = new SimpleDateFormat("EEE MMM d HH:mm:ss z yyyy");
		in.beginObject();
		while (in.hasNext()) {
			switch (in.nextName()) {
			case "Username":
				userTaskList.setUserName(in.nextString());
				break;
			case "IdCounter":
				userTaskList.setIdCounter(in.nextLong());
				break;
			case "TaskList":
				in.beginArray();
				ArrayList<Item> taskArrayList = new ArrayList<Item>();
				while (in.hasNext()) {
					in.beginObject();
					final Item task = new Item();
					while (in.hasNext()) {
						switch (in.nextName()) {
						case "Id":
							task.setId(in.nextLong());
							break;
						case "Type":
							task.setType(in.nextString());
							break;
						case "Title":
							task.setTitle(in.nextString());
							break;
						case "Priority":
							task.setPriority(in.nextString());
							break;
						case "Description":
							task.setDescription(in.nextString());
							break;
						case "Label":
							task.setLabel(in.nextString());
							break;
						case "Status":
							task.setStatus(in.nextString());
							break;
						case "StartDate":
							try {
								task.setStartDate(formatter.parse(in.nextString()));
							} catch (ParseException e) {
								e.printStackTrace();
							}
							break;
						case "EndDate":
							try {
								task.setEndDate(formatter.parse(in.nextString()));
							} catch (ParseException e) {
								e.printStackTrace();
							}
							break;
						}
					}
					taskArrayList.add(task);
					in.endObject();
				}
				userTaskList.setTaskArray(taskArrayList);
				in.endArray();
				break;
			}
		}
		in.endObject();

		return userTaskList;
	}

	@Override
	public void write(JsonWriter out, UserItemList userTaskList) throws IOException {
		out.beginObject();
		out.name("Username").value(userTaskList.getUserName());
		out.name("IdCounter").value(userTaskList.getIdCounter());
		out.name("TaskList").beginArray();

		if (userTaskList.getTaskArray() != null) {
			ArrayList<Item> taskList = userTaskList.getTaskArray();

			for (final Item task : taskList) {
				out.beginObject();
				out.name("Id").value(task.getId());
				out.name("Type").value(task.getType());
				out.name("Title").value(task.getTitle());
				out.name("Priority").value(task.getPriority());
				out.name("Description").value(task.getDescription());
				out.name("Label").value(task.getLabel());
				out.name("Status").value(task.getStatus());
				if (task.getStartDate() != null) {
					out.name("StartDate").value(task.getStartDate().toString());
				}
				if (task.getEndDate() != null) {
					out.name("EndDate").value(task.getEndDate().toString());
				}
				out.endObject();

			}
			out.endArray();
			out.endObject();

		}
	}
}
```
###### utils\ListClassifier.java
``` java
 *
 */
public class ListClassifier {

	private ArrayList<Item> taskArrayList; 
	
	// 
	public static ArrayList<Item> getDoneTaskList(ArrayList<Item> lst){
		ArrayList<Item> result = new ArrayList<Item>();		
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			//Remove this line after proper init of task and evetns
			if(currentTask.getType() == null) continue;
			if (currentTask.getType().toLowerCase().equals("task") &&
					currentTask.getStatus().toLowerCase().equals("overdue")) {
				result.add(currentTask);
			}
		}		
		return result;		
	}
	public static ArrayList<Item> getTaskList(ArrayList<Item> lst){
		ArrayList<Item> result = new ArrayList<Item>();		
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);
			//Remove this line after proper init of task and evetns
			if(currentTask.getType() == null ) continue;
			if (currentTask.getType().toLowerCase().equals("task") &&
					!currentTask.getStatus().toLowerCase().equals("overdue")) {
				result.add(currentTask);
			}
		}		
		return result;		
	}
	// 
	public static ArrayList<Item> getEventList(ArrayList<Item> lst){
		ArrayList<Item> result = new ArrayList<Item>();		
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);	
			if(currentTask.getType() == null) continue;
			if (currentTask.getType().toLowerCase().equals("event")
					&& !currentTask.getStatus().equals("overdue")){
				result.add(currentTask);
			}
		}		
		return result;		
	}
	public static ArrayList<Item> getDoneEventList(ArrayList<Item> lst){
		ArrayList<Item> result = new ArrayList<Item>();		
		for (int i = 0; i < lst.size(); i++) {
			Item currentTask = lst.get(i);	
			if(currentTask.getType() == null) continue;
			if (currentTask.getType().toLowerCase().equals("event")
					&& currentTask.getStatus().equals("overdue")){
				result.add(currentTask);
			}
		}		
		return result;		
	}
	
	
	
	
	
	
	
	public ArrayList<Item> getPendingList() {		
		ArrayList<Item> result = new ArrayList<Item>();		
		for (int i = 0; i < taskArrayList.size(); i++) {
			Item currentTask = taskArrayList.get(i);			
			if (currentTask.getStatus().toLowerCase().equals("pending")) {
				result.add(currentTask);
			}
		}		
		return result;		
	}
	
	public ArrayList<Item> getCompletedList() {
		
		ArrayList<Item> result = new ArrayList<Item>();
		
		for (int i = 0; i < taskArrayList.size(); i++) {
			Item currentTask = taskArrayList.get(i);			
			if (currentTask.getStatus().toLowerCase().equals("completed")) {
				result.add(currentTask);
			}
		}		
		return result;		
	}

	public ArrayList<Item> getOverdueList() {		
		ArrayList<Item> result = new ArrayList<Item>();		
		for (int i = 0; i < taskArrayList.size(); i++) {
			Item currentTask = taskArrayList.get(i);			
			if (currentTask.getStatus().toLowerCase().equals("overdue")) {
				result.add(currentTask);
			}
		}		
		return result;		
	}
	
	public ArrayList<Item> getDeletedList() {		
		ArrayList<Item> result = new ArrayList<Item>();		
		for (int i = 0; i < taskArrayList.size(); i++) {
			Item currentTask = taskArrayList.get(i);			
			if (currentTask.getStatus().toLowerCase().equals("deleted")) {
				result.add(currentTask);
			}
		}
		
		return result;
		
	}
	
	
}
```
###### utils\Settings.java
``` java
 *
 */
public class Settings {
	private String storagePath;
	public Settings() {
		
	}
	
	public String getStoragePath() {
		return storagePath;
	}
	
	public void setStoragePath(String storagePath) {
		this.storagePath = storagePath;
	}
	

}
```
###### utils\SettingsAdapter.java
``` java
 *
 */
public class SettingsAdapter extends TypeAdapter<Settings>{

	@Override
	public Settings read(JsonReader in) throws IOException {
		Settings settings = new Settings();
		in.beginObject();
		while (in.hasNext()) {
			switch (in.nextName()) {
			case "StoragePath":
				settings.setStoragePath(in.nextString());
			}
		}
		in.endObject();
		return settings;
	}

	@Override
	public void write(JsonWriter out, Settings settings) throws IOException {
		out.beginObject();
		out.name("StoragePath").value(settings.getStoragePath());
		out.endObject();
		out.close();
	}

}
```
###### utils\UserItemList.java
``` java
 *
 */
public class UserItemList {
	private String userName;
	private long IdCounter;
	private ArrayList<Item> taskArray;
	
	public UserItemList(String userName, ArrayList<Item> taskArray) {
		this.userName = userName;
		this.taskArray = taskArray;
	}

	public UserItemList() {
	}
	
	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public ArrayList<Item> getTaskArray() {
		return taskArray;
	}

	public void setTaskArray(ArrayList<Item> taskArray) {
		this.taskArray = taskArray;
	}
	
	public long getIdCounter() {
		return IdCounter;
	}

	public void setIdCounter(long idCounter) {
		IdCounter = idCounter;
	}
	// Debugging Method.
	public void printInfo() {
		if (userName == null)
			System.out.println("User not set");
		if (getTaskArray() == null){
			System.out.println("No Task");
			return;
		}

		System.out.println("UserName: " + userName);
		for (int i = 0; i < taskArray.size(); i++) {
			taskArray.get(i).printInfo();		

		}

	}
	

}
```
