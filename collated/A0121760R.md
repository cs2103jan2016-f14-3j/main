# A0121760R
###### src\parser\ArgsParser.java
``` java
 *
 */
public class ArgsParser {
	
	protected static Logger logger = Logger.getLogger("Parser");
	
	protected boolean hasNoArguments = false; 
	protected String commandArgumentsString;
	
	public ArgsParser(String commandArguments){
		commandArgumentsString = commandArguments;
		if (isNullArgument()){
			commandArgumentsString = "";
		}
	}

	private boolean isNullArgument() {
		return commandArgumentsString == null;
	}
	
	public Command invalidArgs(){
		return new InvalidCommand(commandArgumentsString);
	}
}
```
###### src\parser\DeleteParser.java
``` java
 *
 */
public class DeleteParser extends ArgsParser{
	
	private static final String LOG_CREATE_DELETE_PARSER = "DeleteParser Created for \"%s\"";
	static final String MESSAGE_INVALID_ID = "The task ID is invalid!";
	
	private Long itemID;
	private Command InvalidCommand = null;
	
	public DeleteParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		setItemId();
		logger.log(Level.INFO, String.format(LOG_CREATE_DELETE_PARSER ,
												commandArgumentsString));
	}
	
	/**
	 * This method will return the appropriate Command to be processed
	 * by the Command class.
	 * 
	 * @return DelCommand() if the ID is an long. InvalidCommand if it is not.
	 */
	public Command parse(){
		if (isNullInvalidCommand()){
			itemID = new Long(itemID);
			return new DelCommand(itemID);
		} else{
			return InvalidCommand;
		}
	}
	
	/**
	 * This method attempts to see if the ID is a valid integer or not. If it is,
	 * the itemID field is set. Else, the invalidCommand field will be set.
	 */
	public void setItemId(){
		try{
			//checks if itemID is an long.
			itemID = Long.parseLong(commandArgumentsString);
			
		} catch (Exception e){
			//Set the invalidCommand object
			InvalidParser InvalidArgumentParser = new InvalidParser(MESSAGE_INVALID_ID);
			InvalidCommand = InvalidArgumentParser.executeCommand();
		}
	}
	
	private boolean isNullInvalidCommand() {
		return InvalidCommand == null;
	}
}
```
###### src\parser\DoneParser.java
``` java
 *
 */

public class DoneParser extends ArgsParser{
	
	public static final String INVALID_DONE_ARGUMENT_RETURN_MESSAGE = "%s: Is not a valid ID Number";
	private static final String LOG_CREATE_DONE_PARSER = "DoneParser Created for \"%s\"";

	private long itemID;
	private Command invalidCommand = null; 
	
	public DoneParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		getItemId();
		logger.log(Level.INFO, String.format(LOG_CREATE_DONE_PARSER ,
											commandArgumentsString));
	}
	
	/**
	 * This method will return the appropriate Command to be processed
	 * by the Command class.
	 * 
	 * @return DelCommand() if the ID is an integer. InvalidCommand if it is not.
	 */
	public Command parse(){
		if (isNullInvalidCommand()){
			return new EditCommand(itemID, "status", POMPOM.STATUS_COMPLETED);
		} else{
			return invalidCommand;
		}
		
	}

	/**
	 * This method attempts to see if the ID is a valid integer or not. If it is,
	 * the itemID field is set. Else, the invalidCommand field will be set.
	 */
	public void getItemId(){
		try{
			itemID = Long.parseLong(commandArgumentsString);
		} catch (Exception e){
			String returnMsg = String.format(INVALID_DONE_ARGUMENT_RETURN_MESSAGE, commandArgumentsString);
			InvalidParser InvalidArgumentParser = new InvalidParser(returnMsg);
			invalidCommand = InvalidArgumentParser.executeCommand();
		}
	}
	
	private boolean isNullInvalidCommand() {
		return invalidCommand == null;
	}
}
```
###### src\parser\EditParser.java
``` java
 *
 */
public class EditParser extends ArgsParser{
	
	private static final int INDEX_REST_OF_THE_STRING = 1;
	private static final int INDEX_TASK_ID = 0;
	private static final String MESSAGE_NO_ARGUMENTS = "No Arguments";
	private static final String MESSAGE_PROPER_PRIORITY = "Priority only can be set to high/hi/h, medium/med/m or low/lo/l!";
	private static final String MESSAGE_INVALID_DATE_ERROR = "Please enter a vaild date";
	private static final String MESSAGE_INVALID_ARGUMENT_ERROR = "Please enter a vaild argument";
	public static final String MESSAGE_ID_ERROR = "Id must be a number";
	public static final String MESSAGE_TITLE_EMPTY_ERROR = "Title cannot be empty!";
	public static final String MESSAGE_FIELD_ERROR = "There is no such field!";
	private static final String STRING_EMPTY = "";
	private static final int VALID_NUMBER_OF_ARGUMENTS = 2;
	private static final String STRING_SPACE = " ";
	private static final String FIELD_PRIORITY = "priority";
	private static final String FIELD_TITLE = "title";	
	private static final String FIELD_LABEL = "label";
	private static final String FIELD_START_DATE = "start date";
	private static final String FIELD_END_DATE = "end date";
	
	private static final String LOG_CREATE_EDIT_PARSER = "EditParser Created for \"%s\"";

	private static final String[] FIELD_ARRAY = {FIELD_PRIORITY, FIELD_TITLE, 
												 FIELD_LABEL, 
												 FIELD_START_DATE, FIELD_END_DATE};
	
	private long taskID;
	private String field;
	private String newData;
	private String dataErrorMsg;
	private boolean correctId;
	private boolean correctField;
	private boolean correctData;
	private Date newDate = null;
	
	public EditParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		correctId = extractTaskID();
		correctField = extractFields();
		correctData = extractNewData();
		
		logger.log(Level.INFO, String.format(LOG_CREATE_EDIT_PARSER ,
												commandArgumentsString));
	}
	
	public Command parse(){
		
		Command invalidCommand = validateFields();
		if (hasInvalidCommand(invalidCommand)){
			return invalidCommand;
		}
		
		//editing date field
		if (isNotEmptyDate()){
			return new EditCommand(taskID, field, newDate); 
		} else{
			return new EditCommand(taskID, field, newData);
		}
	}
 
	/**
	 * This method gets the ask ID from the command the user has entered.
	 * 
	 * @return
	 * 		true if task ID was sucessfully set. False if not.
	 */			
	public boolean extractTaskID(){
		
		//no arguments was given!
		if(hasNoArguments){
			return false;
		}
		
		//Splits the argument into 2. One part has the task ID. The other has the rest.
		String[] arguments = commandArgumentsString.split(STRING_SPACE,VALID_NUMBER_OF_ARGUMENTS);
		if (isInvalidArgumentsLength(arguments)){
			return false;
		}
		String taskIDString = arguments[INDEX_TASK_ID];				
		commandArgumentsString = arguments[INDEX_REST_OF_THE_STRING];
		
		return canSetTaskID(taskIDString);
	}
	
	/**
	 * This method extracts all the fields inside the command passed by the user.
	 * 
	 * @return
	 */
	public boolean extractFields(){
		if(isInvalidFields()){
			return false;
		}
		for (String currField: FIELD_ARRAY){
			//match currFied (the one inside the field array with the first available field.
			if (isFirstField(currField)){
				field=currField;
				commandArgumentsString = commandArgumentsString.substring(field.length()).trim();
				return true;
			}
		}
		//no fields are matched! means all the fields not valid.
		return false;
	}
	
	/**
	 * This method extracts the data related to the field. Also does validation.
	 * 
	 * @return
	 * 		the appropriate data object for the field
	 */
	public boolean extractNewData(){
		newData = commandArgumentsString;
		if (isNullField()){
			dataErrorMsg = MESSAGE_INVALID_ARGUMENT_ERROR;
			return false;
		}
		
		if (isEmptyTitleField()){
			dataErrorMsg = MESSAGE_TITLE_EMPTY_ERROR;
			return false;
		}
		
		//Process Date
		if (isValidDateField() ){
			return processDateField();
		}
		
		//Process Priority
		if(isProcessingPriorityField()){
			if (field != null) {
				return processPriorityField();
			} 
			else {
				dataErrorMsg = MESSAGE_PROPER_PRIORITY;
				return false;
			}
		}
		if(hasNoArguments){
			dataErrorMsg = MESSAGE_NO_ARGUMENTS;
			return false;
		}
		return true;
	}

	private boolean isProcessingPriorityField() {
		return field == FIELD_PRIORITY;
	}

	private boolean isEmptyTitleField() {
		return field.equals("title") && newData.equals("");
	}

	private boolean isNullField() {
		return field == null;
	}
	/**
	 * This method checks if the data is a valid priority data, then returns
	 * the appropriate priority data than can be used by the command.
	 * 
	 * @return 
	 * 		true if priority is sucessfully set. false if it is not.
	 */
	private boolean processPriorityField() {
		if (isValidHighPriorityCommand(newData)) {
			newData = POMPOM.PRIORITY_HIGH;
			return true;
		} else if (isValidMediumPriorityCommand(newData)){
			newData = POMPOM.PRIORITY_MED;
			return true;
		} else if (isValidLowPriorityCommand(newData)){
			newData = POMPOM.PRIORITY_LOW;
			return true;
		} else {
			dataErrorMsg = MESSAGE_PROPER_PRIORITY;
			return false;
		}
	}
	
	/**
	 * This method checks if the data is a valid date data, then returns
	 * the appropriate date data than can be used by the command.
	 * 
	 * @return 
	 * 		true if priority is sucessfully set. false if it is not.
	 */
	private boolean processDateField() {
		newDate = getDate(newData); 
		if(isNotEmptyDate()){
			return true;
		}else{
			dataErrorMsg = MESSAGE_INVALID_DATE_ERROR;
			return false;
		}
	}
	
	/**
	 * This method attempts to see if the ID is a valid long or not. If it is,
	 * the TaskID field is set. Else, the invalidCommand field will be set.
	 * 
	 * @return 
	 * 		true if can successfully set Task ID. False if cannot.
	 */
	private boolean canSetTaskID(String taskIDString) {
		try{
			taskID = Long.parseLong(taskIDString);
		} catch (Exception e){
			return false;
		}
		return true;
	}
	
	/**
	 * This method checks for all error flags. If any of them is raised, 
	 * an invalidCommand is returned. 
	 * @return
	 * 		invalidCommand with error msg if got raised error flags. false if dont have.
	 */
	private Command validateFields() {
		if(!correctId){
			return new InvalidCommand(MESSAGE_ID_ERROR);
		} else if(!correctField){
			return new InvalidCommand(String.format(MESSAGE_FIELD_ERROR));
		} else if(!correctData){
			return new InvalidCommand(dataErrorMsg);
		} else{
			return null;
		}
	}

	private Date getDate(String data) {
		return POMPOM.timeParser.parseSyntax(data).get(0).getDates().get(0);
	}
	
	public String getField(){
		return field;
	}
	
	public String getNewData(){
		return newData;
	}
	
	private boolean isInvalidArgumentsLength(String[] arguments) {
		return arguments.length < VALID_NUMBER_OF_ARGUMENTS;
	}
	
	private boolean isFirstField(String currField) {
		return commandArgumentsString.indexOf(currField) == 0;
	}

	private boolean isInvalidFields() {
		return commandArgumentsString == null || commandArgumentsString.equals(STRING_EMPTY);
	}
	
	private boolean isValidHighPriorityCommand(String priority){
		//Appropriate commands are: "high", "hi", "h"
		return priority.equalsIgnoreCase(AddParser.PRIORITY_HIGH_CMD1) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_HIGH_CMD2) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_HIGH_CMD3);
	}
	
	private boolean isValidMediumPriorityCommand(String priority){
		//Appropriate commands are: "medium", "med", "m"
		return priority.equalsIgnoreCase(AddParser.PRIORITY_MEDIUM_CMD1) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_MEDIUM_CMD2) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_MEDIUM_CMD3);
	}
	
	private boolean isValidLowPriorityCommand(String priority){
		//Appropriate commands are: "low", "lo", "l"
		return priority.equalsIgnoreCase(AddParser.PRIORITY_LOW_CMD1) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_LOW_CMD2) 
				|| priority.equalsIgnoreCase(AddParser.PRIORITY_LOW_CMD3);
	}
	
	private boolean hasInvalidCommand(Command invalidCommand) {
		return invalidCommand!=null;
	}
	
	private boolean isNotEmptyDate() {
		return newDate != null;
	}

	private boolean isValidDateField() {
		return field.equals(FIELD_START_DATE) || field.equals(FIELD_END_DATE);
	}
	
}
```
###### src\parser\EditParserTest.java
``` java
 *
 */
public class EditParserTest {

	@Test
	public void testGetFields() {
		EditParser editParser = new EditParser("1 title new title");
		assertEquals(editParser.getField(),"title");
	}
	
	/*
	 * New data field has the name of the title inside.
	 */
	@Test
	public void testGetNewData() {
		EditParser editParser = new EditParser("1 title new title");
		assertEquals(editParser.getNewData(),"new title");
	}
	

}
```
###### src\parser\EditRecurringParser.java
``` java
 *
 */
public class EditRecurringParser extends ArgsParser{
	 
	
	private static final String FIELD_PRIORITY = "priority";
	private static final String FIELD_TITLE = "title";	
	private static final String FIELD_LABEL = "label";
	private static final String FIELD_START_DATE = "start date";
	private static final String FIELD_END_DATE = "end date";

	private static final String[] FIELD_ARRAY = {FIELD_PRIORITY, FIELD_TITLE, 
												 FIELD_LABEL, 
												 FIELD_START_DATE, FIELD_END_DATE};
	
	private Long taskID;
	private String field;
	private String newData;
	private Date newDate = null;
	public static final String ID_ERROR_MESSAGE = "Id must be a number!";
	public static final String FIELD_ERROR_MESSAGE = "There is no such field!";
	private static final String LOG_CREATE_EDIT_RECURRING_PARSER = "EditRecuringParser Created for \"%s\"";
	
	boolean correctId;
	boolean correctField;
	boolean correctData;
	String dataErrorMsg;
	
	
	public EditRecurringParser(String userCommand){
		super(userCommand);
		assertNotNull(commandArgumentsString);
		commandArgumentsString = commandArgumentsString.trim();
		correctId = extractTaskID();
		correctField = extractFields();
		correctData = extractNewData();
		logger.log(Level.INFO, String.format(LOG_CREATE_EDIT_RECURRING_PARSER, commandArgumentsString));
	}
	
	public Command parse(){
		if(!correctId){
			return new InvalidCommand(ID_ERROR_MESSAGE);
		}
		if(!correctField){
			return new InvalidCommand(String.format(FIELD_ERROR_MESSAGE));
		}
		if(!correctData){
			return new InvalidCommand(dataErrorMsg);
		}
		else{
			return new EditRecurringCommand(taskID, field, newData);
		}
	}
 
//	private boolean isEditingDateField() {
	//	return (newDate!=null);
	//}
	
	public boolean extractTaskID(){
		if(hasNoArguments){
			return false;
		}
		String[] arguments = commandArgumentsString.split(" ",2);
		if (arguments.length == 0||arguments.length == 1 ){
			return false;
		}
		String taskIDString = arguments[0];				
		commandArgumentsString = arguments[1];
		
		try{
			taskID = Long.parseLong(taskIDString);
			
		} catch (Exception e){
			
		}
		if(taskID == null){
			return false;
		}
		else{
			return true;
		}
	}
	
	public boolean extractFields(){
		if(commandArgumentsString == null || commandArgumentsString.equals("")){
			return false;
		}
		for (String currField: FIELD_ARRAY){
			if (commandArgumentsString.indexOf(currField) == 0){
				field=currField;
				commandArgumentsString = commandArgumentsString.replace(field, "").trim();
				return true;
			}
		}
		return false;
	}
	
	public boolean extractNewData(){
		newData = commandArgumentsString;
		if(field == null){
			dataErrorMsg = "Please enter a vaild argument";
			return false;
		}
		if (field.equals("start date") || field.equals("end date") ){
			newDate = getDate(newData); 
			if(newDate != null){
				
				return true;
			}else{
				dataErrorMsg = "Please enter a vaild date";
				return false;
			}
			
		}		
		if(field == FIELD_PRIORITY){
			if (field != null) {
				if (newData.equalsIgnoreCase("h") || newData.equalsIgnoreCase("high")) {
					newData = POMPOM.PRIORITY_HIGH;
					return true;
				} else if (newData.equalsIgnoreCase("m") || newData.equalsIgnoreCase("med")
						|| newData.equalsIgnoreCase("med")) {
					newData = POMPOM.PRIORITY_MED;
					return true;
				} else if (newData.equalsIgnoreCase("l") || newData.equalsIgnoreCase("low")) {
					newData = POMPOM.PRIORITY_LOW;
					return true;
				} else {
					dataErrorMsg = "Priority only can be set to high medium low!";
					return false; 
				}
			} 
			else {
				dataErrorMsg = "Priority only can be set to high medium low!";
				return false;
			}
		}
		if(hasNoArguments){
			dataErrorMsg = "No Arguments";
			return false;
		}
		return true;
	}

	private Date getDate(String data) {
		return POMPOM.timeParser.parseSyntax(data).get(0).getDates().get(0);
	}
	
	public String getField(){
		return field;
	}
	
	public String getNewData(){
		return newData;
	}
	
}
```
###### src\parser\ExitParser.java
``` java
 *
 */
public class ExitParser{
	
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_EXIT_PARSER = "ExitParser Created";
	
	public Command parse(){
		logger.log(Level.INFO, LOG_CREATE_EXIT_PARSER);
		return new ExitCommand();
	}
}
```
###### src\parser\HelpParser.java
``` java
 *
 */
public class HelpParser{
	
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_HELP_PARSER = "HelpParser Created";
	
	public HelpParser(){
		logger.log(Level.INFO, LOG_CREATE_HELP_PARSER);
	}
	
	public Command parse(){
		return new HelpCommand(); 
	}
}
```
###### src\parser\InvalidParser.java
``` java
 *
 */
public class InvalidParser {
	
	private String invalidCommand;
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_INVALID_PARSER = "InvalidParser Created";
	
	public InvalidParser(String userCommand){
		invalidCommand = userCommand; 	
		assertNotNull(userCommand);
		logger.log(Level.INFO, LOG_CREATE_INVALID_PARSER);
	}
	
	public Command executeCommand(){
		return new InvalidCommand(invalidCommand);
	}
}
```
###### src\parser\Parser.java
``` java
 *
 */
public class Parser {

	/** List of Command types */
	private static final String CMD_ADD = "add";
	private static final String CMD_DELETE = "delete";
	private static final String CMD_DONE = "done";
	private static final String CMD_EDIT = "edit";
	private static final String CMD_EXIT = "exit";
	private static final String CMD_SEARCH = "search";
	private static final String CMD_SHOW = "show";
	private static final String CMD_UNDO = "undo";
	private static final String CMD_PATH = "setpath";
	private static final String CMD_EVENT = "event";
	private static final String CMD_HELP_1 = "help";
	private static final String CMD_TITLE = "title";
	private static final String CMD_HELP_2 = "?";
	private static final String CMD_DELETE_RECUR_1 = "delete r";
	private static final String CMD_EDIT_RECUR_1 = "edit r";
	private static final String CMD_DELETE_RECUR_2 = "deleterecur";
	private static final String CMD_EDIT_RECUR_2 = "editrecur";
	private static final String CMD_VIEW = "view";

	/** List of Invalid command types */
	public static final String INVALID_CMD_MESSAGE = "%s: Command does not exist";

	// private static final int COMMAND_ARRAY_SIZE = 2;
	// private static final int COMMAND_TYPE_INDEX = 0;
	// private static final int COMMAND_ARGUMENT_INDEX = 1;

	private static Parser parserInstance;

	private static Logger logger = Logger.getLogger("Parser");

	public static Parser getInstance() {
		if (parserInstance == null)
			parserInstance = new Parser();

		return parserInstance;
	}

	private Parser() {

	}

	/**
	 * This operation takes in the command specified by the user, executes it
	 * and returns a message about the execution information to the user.
	 * 
	 * @param userCommand
	 *            is the command the user has given to the program
	 * @return the message containing information about the execution of the
	 *         command.
	 */
	public Command parse(String userCommand) {

		String commandType = getStringCommand(userCommand);
		String commandArgument = getStringArgs(userCommand);

		
		// Recur commands must be on top.
		switch (commandType) {
		
		case CMD_EDIT_RECUR_1:
		case CMD_EDIT_RECUR_2:
			EditRecurringParser EditRecurringArgumentParser = new EditRecurringParser(commandArgument);
			return EditRecurringArgumentParser.parse();
		case CMD_DELETE_RECUR_1:
		case CMD_DELETE_RECUR_2:
			DeleteRecurringParser DeleteRecurringParser = new DeleteRecurringParser(commandArgument);
			return DeleteRecurringParser.parse();
		case CMD_ADD:
			AddParser addTaskArgumentParser = new AddParser(commandArgument,false);
			return addTaskArgumentParser.parse();
		case CMD_EVENT:
			AddParser addEventArgumentParser = new AddParser(commandArgument,true);
			return addEventArgumentParser.parse();
		case CMD_DELETE:
			DeleteParser deleteArgumentParser = new DeleteParser(commandArgument);
			return deleteArgumentParser.parse();
		case CMD_EDIT:
			EditParser EditArgumentParser = new EditParser(commandArgument);
			return EditArgumentParser.parse();
		case CMD_SEARCH:
			SearchParser searchParser = new SearchParser(commandArgument);
			return searchParser.parse();
		case CMD_EXIT:
			ExitParser exitParser = new ExitParser();
			return exitParser.parse();
		case CMD_UNDO:
			UndoParser undoParser = new UndoParser();
			return undoParser.parse();
		case CMD_HELP_1:
		case CMD_HELP_2:
			HelpParser helpParser = new HelpParser();
			return helpParser.parse();
		case CMD_PATH:
			return new PathCommand(commandArgument); 
		case CMD_VIEW:
			ViewParser viewParser = new ViewParser(commandArgument);
			return viewParser.parse();
		case CMD_DONE:
			DoneParser DoneArgumentParser = new DoneParser(commandArgument);
			return DoneArgumentParser.parse();
		case CMD_TITLE:
			TitleParser titleParser = new TitleParser(commandArgument);
			return titleParser.parse();
		default:
			String returnMsg = String.format(INVALID_CMD_MESSAGE, commandType);
			InvalidCommand invalidCommand = new InvalidCommand(returnMsg);
			return invalidCommand;
		}

	}

	private static String getStringCommand(String userInput) {
		String[] toSplit = userInput.split(" ", 2);
		return toSplit[0].toLowerCase().trim();
	}

	private static String getStringArgs(String userInput) {
		String[] toSplit = userInput.split(" ", 2);
		if (toSplit.length > 1) {
			return toSplit[1].trim();
		} else {
			return null;
		}
	}

}
```
###### src\parser\ParserTest.java
``` java
 *
 */
public class ParserTest {
	POMPOM pompom = new POMPOM();
	Parser parser = Parser.getInstance();
	
	/*
	 * This is the boundary case for the valid user commands partition
	 */
	@Test
	public void testAddCommand() {
		Command outputCommand = parser.parse("add do cs2013");
		assertTrue(outputCommand instanceof command.AddCommand);
	}
	
	/*
	 * This is the boundary case for the invalid user commands partition
	 */
	@Test
	public void testFailCommand() {
		Command outputCommand = parser.parse("ad do cs2013");
		assertTrue(outputCommand instanceof command.InvalidCommand);
	}
	
	/*
	 * This is the boundary case for the invalid user commands partition
	 */
	@Test
	public void testRecurringCommands() {
		Command outputCommand = parser.parse("delere recur do cs2013");
		assertTrue(outputCommand instanceof command.InvalidCommand);
	}
	


}
```
###### src\parser\SearchParser.java
``` java
 */
public class SearchParser extends ArgsParser{
	
	private static final String STRING_EMPTY = "";
	private static final String MESSAGE_NO_ARGUMENTS_ERROR = "Search must have arguments";
	private static final String LOG_CREATE_SEARCH_PARSER = "SearchParser Created for \"%s\"";;
	private String keyWord;
	
	public SearchParser(String commandArguments) {
		super(commandArguments);
		assertNotNull(commandArgumentsString);
		keyWord = commandArguments;
		logger.log(Level.INFO, String.format(LOG_CREATE_SEARCH_PARSER ,
				commandArgumentsString));
		
	}
	
	public Command parse(){
			if(isInvalidKeyword()){
				return new InvalidCommand(MESSAGE_NO_ARGUMENTS_ERROR);
			}
			return new SearchCommand(keyWord);
	}
	
	private boolean isInvalidKeyword() {
		return keyWord == null || keyWord.equals(STRING_EMPTY);
	}

}
```
###### src\parser\TitleParser.java
``` java
 *
 */
public class TitleParser extends ArgsParser{
	Long id;
	public TitleParser(String commandArguments){
		super(commandArguments);
		
		
	}
	public Command parse(){
		try{
			id = Long.parseLong(this.commandArgumentsString);
		}catch (Exception e){
			return new InvalidCommand(DelCommand.MESSAGE_ID_INVALID);
		}
		return new TitleCommand(id);
	}
}
```
###### src\parser\UndoParser.java
``` java
 *
 */

public class UndoParser {	
	
	protected static Logger logger = Logger.getLogger("Parser");
	private static final String LOG_CREATE_UNDO_PARSER = "UndoParser Created";
	
	public UndoParser(){
		logger.log(Level.INFO, LOG_CREATE_UNDO_PARSER);
	}
	
	public Command parse(){
		return new UndoCommand();
	}
}
```
###### src\parser\ViewParser.java
``` java
 *
 */
public class ViewParser extends ArgsParser{
	
	private String view;
	private static final String LOG_CREATE_VIEW_PARSER = "DeleteParser Created for \"%s\"";
	
	public ViewParser(String commandArgument) {
		super(commandArgument); 
		assertNotNull(commandArgumentsString);
		view = commandArgument;
		logger.log(Level.INFO, String.format(LOG_CREATE_VIEW_PARSER ,
				commandArgumentsString));
	}
	
	public Command parse(){
			return new ViewCommand(view);
	}
}
```
